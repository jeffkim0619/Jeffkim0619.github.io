var t=Object.defineProperty,e=Object.defineProperties,a=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,n=(e,a,r)=>a in e?t(e,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[a]=r;import{u as o,j as d,k as u,h as l}from"./index.43edff7c.js";const i=()=>{const t=o(),i=d((()=>t.state.token.tokenList)),N=d((()=>t.state.token.contractList)),m=d((()=>t.state.token.owner)),O=d((()=>t.state.token.status)),w=d((()=>t.state.mainNet.mainNetName)),E=d((()=>t.state.mainNet.mainNetIdx));return{tokenList:i,getTokenList:async e=>{try{const a=await u.get(l.url.GETCOINLIST+E.value),r=await a.data.resultVO;t.dispatch(l.store.token.SETTOKENLIST,{data:r,idx:e}),t.dispatch(l.store.token.SETOWNER,"")}catch(a){}},getOwnerAdd:async e=>{try{const a=await u.get(l.url.OWNERADDRESS+"networkId="+w.value+"&contractAddress="+e),r=await a.data.resultVO;t.dispatch(l.store.token.SETOWNER,r.data)}catch(a){t.dispatch(l.store.token.SETOWNER,"No Owner")}},ownerAddress:m,getTokenInfo:async t=>{try{const e=await u.get(l.url.TOKENINFO+"networkId="+w.value+"&contractAddress="+t);return await e.data.resultVO}catch(e){}},getAllowance:async(t,e,a)=>{try{const r=await u.get(l.url.ALLOWANCE+w.value+"&contractAddress="+t+"&from="+e+"&spender="+a);return await r.data.resultVO}catch(r){}},resetOwner:()=>{t.dispatch(l.store.token.SETOWNER,"")},getLockUpData:async(t,e)=>{try{const a=await u.get(l.url.LOCKUP+"networkId="+w.value+"&contractAddress="+t+"&address="+e);return await a.data.resultVO}catch(a){}},mainNm:w,getTokenTimeLockInfo:async t=>{try{const e=await u.get(l.url.TOKENTIMELOCKINFO+"networkId="+w.value+"&contractAddress="+t);return await e.data.resultVO}catch(e){}},getTokenTimeLockBalance:async t=>{try{const e=await u.get(l.url.TOKENTIMELOCKBALANCE+"networkId="+w.value+"&contractAddress="+t);return await e.data.resultVO}catch(e){}},getMultiOwner:async t=>{try{const e=await u.get(l.url.MULTI_OWNER+"?networkId="+w.value+"&contractAddress="+t);return await e.data.resultVO}catch(e){}},getMultitransferOwner:async t=>{try{const e=await u.get(l.url.MULTITRANSFERFROM_OWNER+"?networkId="+w.value+"&contractAddress="+t);return await e.data.resultVO}catch(e){}},getContractList:async e=>{try{let a;a=0===e?l.url.MULTISEND_CONTRACT+E.value:l.url.MULTITRANSFER_CONTRACT+E.value;const r=await u.get(a),s=await r.data.resultVO;t.dispatch(l.store.token.SETCONTRACTLIST,s)}catch(a){}},contractList:N,doAction:async(t,o)=>{try{let N,m=(d=((t,e)=>{for(var a in e||(e={}))s.call(e,a)&&n(t,a,e[a]);if(r)for(var a of r(e))c.call(e,a)&&n(t,a,e[a]);return t})({},o.value),i={networkId:w.value},e(d,a(i)));switch(t){case 0:N=l.url.TOKENOWNER;break;case 1:N=l.url.APPROVE;break;case 2:N=l.url.LOCKUPACTION;break;case 3:N=l.url.TRANSFERTOKENTIMELOCK;break;case 4:N=l.url.DEPLOYTOKENTIMELOCK;break;case 5:N=l.url.CHANGEOWNER_MULTISEND;break;case 6:N=l.url.CHANGEOWNER_MULTITRANSFER;break;case 7:N=l.url.COIN_CHARGE;break;case 8:N=l.url.MULTISEND_TRANSFER;break;case 9:N=l.url.MULTITRANSFERFROM_TRANSFER}const O=await u.post(N,m);return await O.data.resultVO}catch(N){}var d,i},transactionCofirmed:async e=>{try{const a=await u.get(l.url.TRANSACTION_CONFIRMED+w.value+"&transactionHash="+e),r=await a.data.resultVO;t.dispatch(l.store.token.SETSTATUS,r)}catch(a){}},status:O,getBalanceMultiSend:async t=>{try{const e=await u.get(l.url.GETBALANCE_MULTISEND+w.value+"&contractAddress="+t);return await e.data.resultVO}catch(e){}},getEvents:async(t,e)=>{try{const a=await u.get(l.url.GETEVENTS+w.value+"&contractAddress="+t+"&contractName="+e);return await a.data.resultVO}catch(a){}},getBalanceMultiTransfer:async(t,e)=>{try{const a=await u.get(l.url.GETBALANCE_MULTITRANSFER+w.value+"&contractAddress="+t+"&tokenAddress="+e);return await a.data.resultVO}catch(a){}},goScanpage:t=>{let e;"ethereum"===w.value?e=l.url.ETHERSCANH+t:"ropsten"===w.value?e=l.url.ROPSTENSCANH+t:"bsc"===w.value&&(e=l.url.BSCSCAN+t),window.open(e)}}},N=()=>{const t=o(),e=d((()=>t.state.mainNet.mainNetName));return{getFee:async()=>{try{const t=await u.get(l.url.GETFEE+e.value);return await t.data.resultVO}catch(t){}},getGasLimit:async t=>{try{let a={};if("charge"===t.methodName||"release"===t.methodName)a={contractAddress:t.contractAddress,contractName:t.contractName,methodName:t.methodName,networkId:e.value,params:[],privateKey:t.privateKey};else if("withdrawls"===t.methodName){let r=[],s=[];t.arrayList.forEach((t=>{let e=t.amount.replace(/(,)/g,"");r.push(t.address),s.push(e)})),a={contractAddress:t.contractAddress,contractName:t.contractName,methodName:t.methodName,networkId:e.value,params:[r,s],privateKey:t.privateKey}}else if("setLock"===t.methodName)a={contractAddress:t.contractAddress,contractName:t.contractName,methodName:t.methodName,networkId:e.value,params:[t.newOwner,t.expireDate,t.lockupAmount],privateKey:t.privateKey};else if("multiTransferFrom"===t.methodName){let r=[],s=[],c=[],n=[];t.arrayList.forEach((t=>{r.push(t.amount),s.push(t.fromAddress),c.push(t.toAddress),n.push(t.tokenAddress)})),a={contractAddress:t.contractAddress,contractName:t.contractName,methodName:t.methodName,networkId:e.value,params:[n,s,c,r],privateKey:t.privateKey}}else a="approve"===t.methodName?{contractAddress:t.contractAddress,contractName:t.contractName,methodName:t.methodName,networkId:e.value,params:[t.approveSpender,t.allowance],privateKey:t.privateKey}:{contractAddress:t.contractAddress,contractName:t.contractName,methodName:t.methodName,networkId:e.value,params:[t.newOwner],privateKey:t.privateKey};const r=await u.post(l.url.GETGASLIMIT,a);return await r.data.resultVO}catch(a){}}}};export{N as b,i as t};
